
## Definitions
1. population matrix
    - square matrix with N candidates
    - for each candidate i in N, value in (i,j) represents the number of people who put candidate i as their jth choice (from the top)
2. preference list + volume vector
    - can be stored as nested dictionary (or custom class)
    - list of candidates ordered by preference
    - volume vector represents number of people with each preference list

## Functions
- preference list + volume vector >> population matrix (trivial)
- population matrix >> preference list + volume vector (one-to-many)
- need some visualization to play with the many options (slider)

## Simulations
- compute Plurality and Borda result from a population matrix


## Pseudocode

```python
class Candidate:
    def __init__(self, name: str):
        self.name = name
        # generate unique alphanumeric ID for large simulations

# in an election, generate multiple candidates
# - add, remove

class Agent:
    def __init__(self, preferences: list[Candidate]):
        self.preferences = preferences
        # checks to verify preference validity
        # - each candidate appears only once
        # - length of list == length of available candidates

    def top_choice(self):
        return self.preferences[0]

    # do not edit during an election to backtrack individual preferences

class Population:
    # default constructor = list of agents
    def __init__(self, preference_lists: list[Agent]):
        self.preference_lists = preference_lists
        self.population_matrix = build_matrix(preference_lists)

    # second constructor = from a population matrix
    @classmethod
    def from_matrix():

    # third constructor = from list of agents and associated volume vector (default vector of ones)
    @classmethod
    def from_preferences(archetypes: list[Agent], volume_vector: list[int]):
        # check that length(volume_vector) == length(archetypes) 


class VotingSystem:
    def run_election(self, population: Population) -> Candidate:

class PluralityVoting(VotingSystem):
    def run_election(self, population: Population) -> Candidate:

class BordaCount(VotingSystem):
    def run_election(self, population: Population) -> Candidate:

# implement other voting systems accordingly


class Election:
    def __init__(self, candidates: list[Candidate], population: Population, system: VotingSystem):
        self.candidates = candidates
        self.population = population
        self.system = system
    
    # at a later stage, need to deal with VotingSystems that output set of candidates and probability distributions

    def run(self):
        winner = self.system.run_election(self.population)
        print(f"Winner: {winner.name}")
        return winner
```