
## Definitions
1. population matrix
    - square matrix with N candidates
    - for each candidate i in N, value in (i,j) represents the number of people who put candidate i as their jth choice (from the top)
2. preference list + volume vector
    - can be stored as nested dictionary (or custom class)
    - list of candidates ordered by preference
    - volume vector represents number of people with each preference list

## Functions
- preference list + volume vector >> population matrix (trivial)
- population matrix >> preference list + volume vector (one-to-many)
- need some visualization to play with the many options (slider)

## Simulations
- compute Plurality and Borda result from a population matrix


## Pseudocode

```python
class Candidate:
    def __init__(self, name: str):
        self.name = name
        # generate unique alphanumeric ID for large simulations

# in an election, generate multiple candidates
# - add, remove

class Agent:
    def __init__(self, preferences: list[Candidate]):
        self.preferences = preferences
        # checks to verify preference validity
        # - each candidate appears only once
        # - length of list == length of available candidates

    def top_choice(self):
        return self.preferences[0]

    # do not change during an election to backtrack individual preferences

class Population:
    # default constructor = list of agents
    def __init__(self, preference_lists: list[Agent]):
        self.preference_lists = preference_lists
        self.population_matrix = build_matrix(preference_lists)

    # secondary constructor = from a population matrix
    @classmethod
    def from_matrix():

    # third constructor = list of agents, volume vector
    @classmethod
    def from_preferences(archetypes: list[Agent], volume_vector: list[int]):
        # check that length(volume_vector) == length(archetypes) 


class Election:
    def __init__(self population: Population):

    @staticmethod
    def Plurality():

    @staticmethod
    def Borda():
```